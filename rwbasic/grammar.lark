// Common base tokens
%import common (DIGIT, HEXDIGIT, NEWLINE, LETTER)

// Ignore whitespace
%import common (WS_INLINE)
%ignore WS_INLINE

// Numeric literal tokens
BOOLEAN_LITERAL: "TRUE"i | "FALSE"i
BINARY_LITERAL: "%" ("0".."1")+
DECIMAL_LITERAL: DIGIT+
HEX_LITERAL: "&" HEXDIGIT+
_EXPONENT: "E"i ["+" | "-"] DIGIT+
_FIXED_LITERAL: DECIMAL_LITERAL "." DECIMAL_LITERAL?
FLOAT_LITERAL: DECIMAL_LITERAL _EXPONENT | _FIXED_LITERAL _EXPONENT?

// String literal
STRING_LITERAL: "\"" (/[^"]/ | "\"\"")* "\""

// Variable reference. Low priority so we prefer matching terminals like TRUE and FALSE first.
VARIABLE.-1: LETTER (LETTER | DIGIT)* ("$" | "%")?

POWEROP: "^"
MULOP: "*" | "/"
ADDOP: "+" | "-"
EQUALS: "="
COMPOP: "<>" | "<" | ">" | "<=" | ">=" | "<<" | ">>" | ">>>"

// Keywords.
// TODO: abbreviations, see e.g. https://central.kaserver5.org/Kasoft/Typeset/BBC/Ch47.html
AND: "AND"i
DIV: "DIV"i
END: "END"i
EOR: "EOR"i
FOR: "FOR"i
LET: "LET"i
MOD: "MOD"i
NEW: "NEW"i
NEXT: "NEXT"i
NOT: "NOT"i
OR: "OR"i
PRINT: "PRINT"i
REM: "REM"i
RUN: "RUN"i
STEP: "STEP"i
TO: "TO"i

// Comment. Will match to end of line including any ":" characters.
COMMENT: REM /[^\r\n]/*

// Print formatting
PRINT_ITEM_SEPARATOR: ";" | "," | "'"

// A program definition
program: (program_line NEWLINE)* program_line
?program_line: numbered_line_definition | unnumbered_line_definition
unnumbered_line_definition: line_definition_statements
numbered_line_definition: DECIMAL_LITERAL line_definition_statements

// Input to the interactive prompt
?promptline: numbered_line_definition | prompt_line_statements

// Statements which can appear in line definitions.
line_definition_statements: (line_definition_statement ":")* line_definition_statement?
?line_definition_statement: statement

// Statements which can appear in the prompt line.
prompt_line_statements: (prompt_line_statement ":")* prompt_line_statement?
?prompt_line_statement: statement
                      | new_statement
                      | run_statement

// Statements within a line which can appear in line definitions or the prompt line.
?statement: comment_statement
          | print_statement
          | let_statement
          | end_statement
          | for_statement
          | next_statement

comment_statement: COMMENT
print_statement: PRINT (expression+ PRINT_ITEM_SEPARATOR)* expression*
let_statement: LET? VARIABLE EQUALS expression
run_statement: RUN
new_statement: NEW
end_statement: END
for_statement: FOR VARIABLE EQUALS expression TO expression (STEP expression)?
next_statement: NEXT VARIABLE?

// Expressions
?andop: AND
?orop: OR | EOR
?unaryop: ADDOP | NOT // TODO indirection
?mulop: MULOP | DIV | MOD
?compop: EQUALS | COMPOP

?expression: orexpr
?orexpr: (andexpr orop)* andexpr
?andexpr: (compexpr andop)* compexpr
?compexpr: (addexpr compop)* addexpr
?addexpr: (mulexpr ADDOP)* mulexpr
?mulexpr: (powerexpr mulop)* powerexpr
?powerexpr: (unaryexpr POWEROP)* unaryexpr
?unaryexpr: unaryop* atomexpr
?atomexpr: "(" expression ")"
         | numliteralexpr
         | strliteralexpr
         | variablerefexpr
numliteralexpr: BOOLEAN_LITERAL | BINARY_LITERAL | DECIMAL_LITERAL | HEX_LITERAL | FLOAT_LITERAL
strliteralexpr: STRING_LITERAL
variablerefexpr: VARIABLE
