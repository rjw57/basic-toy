// Common base tokens
%import common (DIGIT, HEXDIGIT)

// Ignore whitespace
%import common (WS_INLINE)
%ignore WS_INLINE

// Numeric literal tokens
BOOLEAN_LITERAL: "TRUE"i | "FALSE"i
BINARY_LITERAL: "%" ("0".."1")+
DECIMAL_LITERAL: DIGIT+
HEX_LITERAL: "&" HEXDIGIT+
_EXPONENT: "E"i ["+" | "-"] DIGIT+
_FIXED_LITERAL: DECIMAL_LITERAL "." DECIMAL_LITERAL?
FLOAT_LITERAL: DECIMAL_LITERAL _EXPONENT | _FIXED_LITERAL _EXPONENT?

// String literal
STRING_LITERAL: "\"" (/[^"]/ | "\"\"")* "\""

// Classes of operator tokens grouped by priority. Operators listed first are acted upon before
// operators listed second and so on.
UNARYOP: "+" | "-" | "NOT"i // TODO: indirection
POWEROP: "^"
MULOP: "*" | "/" | "DIV"i | "MOD"i
ADDOP: "+" | "-"
COMPOP: "=" | "<>" | "<" | ">" | "<=" | ">=" | "<<" | ">>" | ">>>"
ANDOP: "AND"i
OROP: "OR"i | "EOR"i

// Symbols
SEMICOLON: ";"

// Keywords
PRINT: "PRINT"i

// An individual line presented for parsing.
?start: line

line: (statement ":")* statement

statement: comment
         | expression
         | printstmt

printstmt: PRINT expression SEMICOLON?

comment: "REM"i /./*

// Expressions
?expression: orexpr
?orexpr: (andexpr OROP)* andexpr
?andexpr: (compexpr ANDOP)* compexpr
?compexpr: (addexpr COMPOP)* addexpr
?addexpr: (mulexpr ADDOP)* mulexpr
?mulexpr: (powerexpr MULOP)* powerexpr
?powerexpr: (unaryexpr POWEROP)* unaryexpr
?unaryexpr: UNARYOP* atomexpr
?atomexpr: "(" expression ")"
         | literalexpr

literalexpr: BOOLEAN_LITERAL | BINARY_LITERAL | DECIMAL_LITERAL | HEX_LITERAL | FLOAT_LITERAL
           | STRING_LITERAL
